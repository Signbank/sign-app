import json
import numpy as np

# Look at this number of elements of a list
# Only the first part of the set is important see research paper on the wiki
NUMBER_OF_SET_TO_US = 5


class Tree:
    """
    This class manages the different sign properties for the search by properties feature.
    The different properties are stored in their respective lists and can be managed by the different methods in this class.
    """

    def __init__(self):
        self.nodes = []

    def create_from_file(self, file_path):
        """
        Create a tree from the given file.
        This file is generated by the get_sign_property_data script in the data_scripts folder
        """

        if not file_path.exists():
            return

        with open(file_path, 'r', encoding='utf-8') as file:
            dictionary_of_signs = json.load(file)

        # Create a dictionary that stores all the weights per sign
        # This is used to calculate what is the best set to ask to the user
        weight_dictionary = {}
        for key in dictionary_of_signs:
            weight_dictionary[key] = dictionary_of_signs[key].pop(0)

        # Parent node with all sign ids.
        # This will create a node with the list of edges will go to all signs
        parent_node = Node('p', list(dictionary_of_signs.keys()))
        self.add_edges(parent_node, dictionary_of_signs, weight_dictionary)
        self.nodes = parent_node.edges

    def get_best_spread_of_signs(self, node, dictionary_of_signs, weight_dictionary):
        """
        This method looks at every possible property set and then returns the index of the best set
        """

        # Check how many items are left over
        number_of_items = len(list(dictionary_of_signs.values())[0])
        if number_of_items <= 1:
            return 0

        list_of_weight_dictionaries = [{} for _ in range(number_of_items)]

        for i, sign_id in enumerate(node.sign_ids):
            sign = dictionary_of_signs[sign_id]
            weight = weight_dictionary[sign_id]

            if sign == []:
                return 0

            for j, sign_property in enumerate(sign):
                property_weight_dictionary = list_of_weight_dictionaries[j]
                if sign_property in property_weight_dictionary:
                    property_weight_dictionary[sign_property] += weight
                else:
                    property_weight_dictionary[sign_property] = weight

            if i >= NUMBER_OF_SET_TO_US or i == len(node.sign_ids)-1:
                best_set = self.get_index_of_best_spread_set(list_of_weight_dictionaries)
                return best_set

        # Return base value
        return 0

    def get_index_of_best_spread_set(self, list_of_weight_dictionaries):
        """
        This method check which dictionary has the best spread and return the index of that property
        """
        best_set_value = -1
        best_index = 0
        for i, dic in enumerate(list_of_weight_dictionaries):
            weight_list = list(dic.values())
            std = np.std(weight_list)
            if std <= best_set_value or best_set_value == -1:
                best_set_value = std
                best_index = i

        return best_index

    def add_edges(self, node, dictionary_of_signs, weight_dictionary):
        """
        Add edges to other node that are used in the same signs
        """
        best_index = self.get_best_spread_of_signs(node, dictionary_of_signs, weight_dictionary)

        for sign_id in node.sign_ids:
            sign = dictionary_of_signs[sign_id]
            if sign == []:
                break
            sign_property = sign.pop(best_index)

            edge = Node(sign_property, [sign_id])
            node.add_edge(edge)

        for edge in node.edges:
            self.add_edges(edge, dictionary_of_signs, weight_dictionary)

    def get_next_node_list_for_user(self, list_of_node_indexes):
        """
        Retrieves and return the node list based on the list of indexes
        """
        node_list = self.nodes

        for index in list_of_node_indexes:
            if index >= len(node_list):
                return []
            node_list = node_list[index].edges

        return node_list

    def __str__(self):
        return_string = ""

        for node in self.nodes:
            return_string = return_string + str(node) + "\n"

        return return_string

    def __eq__(self, other):
        if Tree != type(other):
            return False

        if self.nodes != other.nodes:
            return False

        return True


class Node:
    """
    This class represents a property in the tree
    It holds a list of edges that represent all
    the other properties that are used in the same sign as this property
    """

    def __init__(self, identifier, sign_ids=None):
        self.identifier = identifier
        self.edges = []
        if sign_ids is None:
            self.sign_ids = []
        else:
            self.sign_ids = sign_ids

    def add_edge(self, new_edge):
        """
        This method checks if this node already contains the same edge.
        This make sure there are no duplicate edges
        """
        try:
            edge_index = self.edges.index(new_edge)
            if new_edge.sign_ids != []:
                self.edges[edge_index].add_sign_id(new_edge.sign_ids[0])
        except ValueError:
            self.edges.append(new_edge)

    def add_sign_id(self, sign_id):
        """
        Checks if a sign id is already pressant before adding it.
        This way there are no duplicate id's
        """
        if sign_id not in self.sign_ids:
            self.sign_ids.append(sign_id)

    def __eq__(self, other):
        if Node != type(other):
            return False

        if self.identifier != other.identifier:
            return False

        if self.edges != other.edges:
            return False

        return True

    def __str__(self):
        return_string = f"Node Id:{self.identifier}, sign id's: {self.sign_ids}"
        return return_string
