"""Module for use of graph with different sign properties"""
import json
from functools import reduce
from operator import iconcat
import numpy as np


class Graph:
    """
    This class manages the different sign properties for the search by properties feature.
    The different properties are stored in their respective lists and can be managed by the different methods in this class.

    A property is a node of the graph and has at least two outgoing edges.
    These edges are the properties that are all used in a sign.
    """

    def __init__(self):
        self.nodes = []

    def create_graph_from_file(self, file_path):
        """
        This function creates the graph from a file that is
        generated by the data scripts.
        It is based of the different sign properties and
        relevance base on the value in that file.
        """

        if not file_path.exists():
            return

        with open(file_path, 'r', encoding='utf-8') as file:
            list_of_signs = json.load(file)

        # Add a list for every different property
        for i in range(len(list_of_signs[1]) - 2):
            self.nodes.append([])

        for values in list_of_signs:
            sign_id = values.pop(0)
            weight = values.pop(0)

            for i in range(len(values)):
                # Copy property list so that we keep the original list
                item = values.copy()

                # Get the value of the main/parent node
                value = item.pop(i)

                parent_node = self.add_node(Node(value, i, len(values), [sign_id]))

                # Go throug all the remaining items and create nodes and edges that are a part of the parent node
                for j in range(len(item)):
                    self.add_edge_rec(weight, values, parent_node, item.copy())

                    # Remove the first item and add it to the end of the list
                    # This way all the different items are added in every differnt order
                    item.append(item.pop(0))

    def add_edge_rec(self, weight, original_list, parent_node, value_list):
        """
        Add an edge to every node with recursion
        For every next value in the list a node is created and an edge added
        to the previous node that points to the created node
        """
        if value_list == []:
            return

        value = value_list.pop(0)
        sign_id = parent_node.sign_ids[-1]

        # Get the correct group that the node belongs to
        for i, original_value in enumerate(original_list):
            if i == parent_node.group:
                continue

            if value == original_value:
                current_group = i
                break

        node = Node(value, current_group, len(parent_node.edges), [sign_id])
        edge = parent_node.add_edge(Edge(node, weight))

        # If the edge already exists then add the current sign id to the list
        # and use the existing node to add that have the same first edge
        if edge is not None:
            node = edge.node
            node.add_sign_id(sign_id)

        self.add_edge_rec(weight, original_list, node, value_list)

    def add_node(self, new_node):
        """
        Adds a new node to the correct list
        """
        node_list = self.nodes[new_node.group]

        node = self.get_node_from_list(new_node, node_list)

        if node is not None:
            node.add_sign_id(new_node.sign_ids[0])
            return node

        new_node.index = len(node_list)
        node_list.append(new_node)
        return new_node

    def get_node_from_list(self, new_node, node_list):
        """
        Checks if the node is already in the list and return it if it does
        """
        for node in node_list:
            if node.identifier == new_node.identifier:
                return node

        return None

    def pick_property_set(self, list_of_node_index):
        """
        Pick the best property based on already chosen nodes
        The function receives a list of tuples containing the group and index of the node
        """

        if list_of_node_index == []:
            return self.pick_first_set()

        node = self.get_sub_node_by_index_list(list_of_node_index)

        return self.pick_best_set(node)

    def get_sub_node_by_index_list(self, index_list):
        """
        Retrieves and return the node base on the list of indexes
        """
        first_index = index_list.pop(0)
        node = self.nodes[first_index[0]][first_index[1]]

        for index_tuple in index_list:
            node = node.edges[index_tuple[0]][index_tuple[1]].node

        return node

    def pick_first_set(self):
        """
        Returns the list of nodes that has the most even spread
        """
        spread_values = []

        for node_list in self.nodes:
            spread_values.append(self.calculated_set_spread(node_list))

        index_best_set = 0

        for i, spread in enumerate(spread_values):
            if spread < spread_values[index_best_set]:
                index_best_set = i

        return self.nodes[index_best_set]

    def pick_best_set(self, picked_node):
        """
        Pick the best spread properties from all the outgoing edges from the chosen node
        """

        if picked_node.has_no_edges():
            return [picked_node]

        spread_values = []

        for edge_list in picked_node.edges:
            # Skip the empty edge list
            if edge_list == []:
                # Add an empty list so that the count stays the same as the property count
                spread_values.append(-1)
                continue

            weight_list = [edge.weight for edge in edge_list]
            spread = np.std(weight_list) * np.ptp(weight_list)
            spread_values.append(spread)

        index_best_set = 0

        # If the picked node is of the first group then the first list is empty
        if index_best_set == picked_node.group:
            index_best_set = 1

        for i, spread in enumerate(spread_values):
            # If the first set is zero increase the index by one two compare the other two values
            # if i == 0 and spread == -1:
            #     print(f"\n Increase index. i:{i}, spread:{spread}")
            #     index_best_set += 1
            #     continue
            if spread == -1:
                continue

            if spread < spread_values[index_best_set]:
                index_best_set = i

        return [edge.node for edge in picked_node.edges[index_best_set]]

    def calculated_set_spread(self, node_list):
        """
        Looks to all the weights form all edges of the node list
        and returns the spread of these weights.
        """
        weight_list = []

        for node in node_list:
            edge_list = []
            reduce(iconcat, node.edges, edge_list)
            weight_list += [edge.weight for edge in edge_list]

        return np.std(weight_list) * np.ptp(weight_list)

    def __eq__(self, other):
        if Graph != type(other):
            return False

        if self.nodes != other.nodes:
            return False

        return True

    def __str__(self):
        return_string = ""

        for node_list in self.nodes:
            for node in node_list:
                return_string = return_string + str(node) + "\n"

        return return_string


class Node:
    """
    This class represents a property in the graph
    It holds a list of edges that represent all
    the other properties that are used in the same sign as this property
    """

    def __init__(self, identifier, group, nr_of_sets=1, sign_ids=None):
        """
        Set values of a node, the number of sets is should be the same as in the graph
        This means that one list is empty because a node has no edges to the same group as itself
        The reason behind this is that it is now still possible to use the same group index as for the graph
        """
        self.identifier = identifier
        self.group = group
        self.edges = [[] for i in range(nr_of_sets)]
        if sign_ids is None:
            self.sign_ids = []
        else:
            self.sign_ids = sign_ids
        self.index = 0

    def add_edge(self, new_edge):
        """
        This method checks if this node already contains the same edge.
        This make sure there are no duplicate edges
        """
        group = new_edge.node.group
        for edge in self.edges[group]:
            if edge == new_edge:
                edge.weight += new_edge.weight
                return edge

        new_edge.node.index = len(self.edges[group])
        self.edges[group].append(new_edge)
        return None

    def add_sign_id(self, sign_id):
        """
        Checks if a sign id is already pressent before adding it.
        This way there are no duplicate id's
        """
        if sign_id not in self.sign_ids:
            self.sign_ids.append(sign_id)

    def has_no_edges(self):
        """
        If an node has no edges return True
        """
        for edge_list in self.edges:
            if edge_list != []:
                return False

        return True

    def __eq__(self, other):
        if Node != type(other):
            return False

        if self.identifier != other.identifier:
            return False

        if self.group != other.group:
            return False

        if self.edges != other.edges:
            return False

        return True

    def __lt__(self, other):
        if Node != type(other):
            return False

        return self.group < other.group

    def __str__(self):
        return_string = f"Node Id:{self.identifier}, group:{self.group}, sign id's: {self.sign_ids}"
        for edge_list in self.edges:
            for edge in edge_list:
                return_string += f"\n       Edge: {edge}"

        return return_string


class Edge:
    """
    An edge represents the link between two properties that er used in the same sign
    """

    def __init__(self, node, weight):
        self.node = node
        self.weight = weight

    def __eq__(self, other):
        if Edge != type(other):
            return False

        # compare values of nodes instead of
        # nodes self to avoid possible infinite recursion
        if self.node.identifier != other.node.identifier:
            return False

        if self.node.group != other.node.group:
            return False

        return True

    def __lt__(self, other):
        if Edge != type(other):
            return False

        return (self.node.group, self.weight) < (other.node.group, other.weight)

    def __str__(self):
        return f"Weight:{self.weight}, \
               To: id:{self.node.identifier} group:{self.node.group}"
